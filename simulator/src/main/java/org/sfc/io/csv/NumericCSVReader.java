/*
 * Copyright (c) 2006 Thomas Weise
 * Software Foundation Classes
 * http://sourceforge.net/projects/java-sfc
 *
 * E-Mail           : tweise@gmx.de
 * Creation Date    : 2007-07-21
 * Creator          : Thomas Weise
 * Original Filename: org.sfc.io.csv.NumericCSVReader.java
 * Last modification: 2007-07-21
 *                by: Thomas Weise
 *
 * License          : GNU LESSER GENERAL PUBLIC LICENSE
 *                    Version 2.1, February 1999
 *                    You should have received a copy of this license along
 *                    with this library; if not, write to theFree Software
 *                    Foundation, Inc. 51 Franklin Street, Fifth Floor,
 *                    Boston, MA 02110-1301, USA or download the license
 *                    under http://www.gnu.org/licenses/lgpl.html or
 *                    http://www.gnu.org/copyleft/lesser.html.
 *
 * Warranty         : This software is provided "as is" without any
 *                    warranty; without even the implied warranty of
 *                    merchantability or fitness for a particular purpose.
 *                    See the Gnu Lesser General Public License for more
 *                    details.
 */

package org.sfc.io.csv;

import java.io.File;
import java.io.FileFilter;
import java.util.Arrays;
import java.util.Comparator;
import java.util.regex.Pattern;

import org.sfc.collections.lists.SimpleList;
import org.sfc.io.CanonicalFile;
import org.sfc.io.IO;
import org.sfc.io.TextWriter;
import org.sfc.io.loaders.ReaderLoader;
import org.sfc.math.Mathematics;
import org.sfc.utils.ErrorUtils;
import org.sfc.utils.Utils;

/**
 * This utility class is able to read CSV files with numerical content,
 * like the writings of the
 * {@link org.sigoa.refimpl.pipe.stat.ObjectivePrinterPipe} from a directoy
 * back into an array of <code>double</code>s.
 * 
 * @author Thomas Weise
 */
public class NumericCSVReader {

  /**
   * the empty <code>double[][][]</code>- array
   */
  public static final double[][][] EMPTY_DOUBLE3 = new double[0][][];

  /**
   * the empty <code>double[][]</code>- array
   */
  public static final double[][] EMPTY_DOUBLE2 = new double[0][];

  /**
   * the empty <code>double[]</code>- array
   */
  public static final double[] EMPTY_DOUBLE1 = new double[0];

  /**
   * the empty <code>double[][][][]</code>- array
   */
  public static final double[][][][] EMPTY_DOUBLE4 = new double[0][][][];

  /**
   * the regex
   */
  public static final Pattern REGEX = Pattern.compile("\\s"); //$NON-NLS-1$

  /**
   * the min cmp value
   */
  private static final double MIN_CMP = Math.log10(Double.MIN_VALUE) - 0.1;

  /**
   * the internal file filter
   */
  private static final FileFilter DIRECTORY_FILTER = new FileFilter() {
    public final boolean accept(final File pathname) {
      return ((pathname != null) && (pathname.isFile())
          && (pathname.exists()) && (pathname.canRead()));
    }
  };

  /**
   * the internal comparator for double arrays
   */
  private static final Comparator<double[]> CMP = new Comparator<double[]>() {
    public final int compare(final double[] d1, final double[] d2) {
      int i, j;
      for (i = 0; i < d1.length; i++) {
        j = Double.compare(d1[i], d2[i]);
        if (j != 0)
          return j;
      }
      return 0;
    }
  };

  /**
   * <p>
   * This function reads all the files generated by an objective printer
   * from one directory into an array of <code>double[][][]</code>.
   * </p>
   * <p>
   * For each single file in the directory, an array of
   * <code>double[][]</code> is created. This array's items are the
   * single rows of the file.
   * </p>
   * <p>
   * Access the result array as follows <code>res[A][B][C]</code> where
   * <ul>
   * <li><code>[A]</code> identifies the file read from the directory</li>
   * <li><code>[B]</code> identifies the (valid) row in that file</li>
   * <li><code>[C]</code> identifies the column in that row</li>
   * </ul>
   * </p>
   * 
   * @param directory
   *          the directory
   * @param removeDuplicates
   *          <code>true</code> if and only if duplicates are to be
   *          removed per file
   * @param ignoreFirstLine
   *          <code>true</code> if and only if the first line in the file
   *          should be ignored (because it contains the headline)
   * @return the <code>double[][]</code>-array
   */
  public static final double[][][] readDirectory(final Object directory,
      final boolean removeDuplicates, boolean ignoreFirstLine) {
    CanonicalFile f;
    File[] fs;
    double[][][] d;
    int i;
    SimpleList<Object> sl;
    ReaderLoader l;

    f = IO.getFile(directory);
    if ((f == null) || (!(f.isDirectory())))
      return EMPTY_DOUBLE3;

    fs = f.listFiles(DIRECTORY_FILTER);
    if ((fs == null) || ((i = fs.length) <= 0))
      return EMPTY_DOUBLE3;
    Arrays.sort(fs);

    d = new double[i][][];
    l = new ReaderLoader();

    sl = new SimpleList<Object>();

    for (--i; i >= 0; i--) {
      d[i] = readFile(fs[i], removeDuplicates, ignoreFirstLine, sl, l);
    }

    return d;
  }

  /**
   * <p>
   * Read the csv output stored in a file.
   * </p>
   * <p>
   * Access the result array as follows <code>res[A][B]</code> where
   * <ul>
   * <li><code>[A]</code> identifies the (valid) row in the file</li>
   * <li><code>[B]</code> identifies the column in that row</li>
   * </ul>
   * </p>
   * 
   * @param file
   *          the file to read
   * @param sl
   *          the internal simple list
   * @param removeDuplicates
   *          <code>true</code> if and only if duplicates are to be
   *          removed per file
   * @param ignoreFirstLine
   *          <code>true</code> if and only if the first line in the file
   *          should be ignored (because it contains the headline)
   * @param loader
   *          the reader loader
   * @return the data
   */
  public static final double[][] readFile(final Object file,
      final boolean removeDuplicates, final boolean ignoreFirstLine,
      final SimpleList<Object> sl, final ReaderLoader loader) {
    int i, c, l;
    String[] s;
    double[] d;
    double[][] xx;
    Object[] x;

    if (loader.load(file)) {
      CSVReader.parseCSVData(loader.getData(), 0, loader.getLength(),
          removeDuplicates, sl);

      c = sl.m_count;
      if (c > 0) {
        x = sl.m_data;
        if (ignoreFirstLine)
          // x[0] = x[--c];
          System.arraycopy(x, 1, x, 0, --c);

        main: for (i = (c - 1); i >= 0; i--) {
          s = (String[]) (x[i]);
          l = s.length;
          if (l > 0) {
            d = stringsToDoubleArray(s);
            if (d != EMPTY_DOUBLE1) {
              x[i] = d;
              continue main;
            }
          }
          // x[i] = x[--c];
          System.arraycopy(x, i + 1, x, i, ((--c) - i));
        }

        if (c > 0) {
          xx = new double[c][];
          System.arraycopy(x, 0, xx, 0, c);
          // sort(xx);
          loader.reset();
          sl.m_count = 0;
          return xx;
        }
      }
    }

    loader.reset();
    sl.m_count = 0;
    return EMPTY_DOUBLE2;
  }

  /**
   * Sort a given data array.
   * 
   * @param data
   *          the data array
   */
  public static final void sort(final double[][] data) {
    Arrays.sort(data, CMP);
  }

  /**
   * Sort a given data array.
   * 
   * @param data
   *          the data array
   */
  public static final void sort(final double[][][] data) {
    int i;
    for (i = (data.length - 1); i >= 0; i--)
      sort(data[i]);
  }

  /**
   * This internal function splits a data array into consecutive units all
   * contaning the same elements.
   * 
   * @param data
   *          the data array
   * @param list
   *          a simple list with the single lines
   */
  private static final void split(final SimpleList<double[][][]> list,
      final double[][][] data) {
    double[][] x, x2, t;
    double[] d;
    int i, j, k, m;
    double[][][] r;
    final int l;

    sort(data);

    l = data.length;
    for (i = (l - 1); i >= 0; i--) {
      x = data[i];
      for (j = (x.length - 1); j >= 0; j--) {
        d = x[j];
        if (d.length > 0) {
          r = new double[l][][];
          Arrays.fill(r, EMPTY_DOUBLE2);

          r[i] = t = new double[][] { d };

          inner: for (k = (i - 1); k >= 0; k--) {
            x2 = data[k];
            for (m = (x2.length - 1); m >= 0; m--) {
              if (Utils.testDoubleArrayEqual(x2[m], d)) {
                r[k] = t;
                x2[m] = EMPTY_DOUBLE1;
                continue inner;
              }
            }
          }

          x[j] = EMPTY_DOUBLE1;

          list.add(r);
        }
      }
    }

  }

  /**
   * This internal function unites consecutive units that all contaning the
   * same elements into consecutive units that all contain similar
   * elements.
   * 
   * @param list
   *          a simple list with the single lines
   */
  private static final void unite(final SimpleList<double[][][]> list) {
    int i, j, min, minI, minJ, q, l;
    double[][][] c1, c2;
    int[][] matrix;
    int[] kk;

    l = list.m_count;
    if (l <= 1)
      return;

    matrix = new int[l][];
    for (i = (l - 1); i >= 0; i--)
      matrix[i] = new int[i];

    for (i = (l - 1); i > 0; i--) {
      c1 = list.get(i);
      for (j = (i - 1); j >= 0; j--) {
        matrix[i][j] = compareLines(c1, list.get(j));
      }
    }

    for (;;) {
      if (l <= 1)
        return;

      minI = 0;
      minJ = 0;
      min = Integer.MAX_VALUE;
      outer: for (i = (l - 1); i > 0; i--) {
        for (j = (i - 1); j >= 0; j--) {
          q = matrix[i][j];
          if ((q >= 0) && (q < min)) {
            min = q;
            minI = i;
            minJ = j;
            if (q <= 1)
              break outer;
          }
        }
      }

      if (min == Integer.MAX_VALUE)
        return;

      c1 = list.get(minI);
      c2 = list.get(minJ);
      for (q = (Math.min(c1.length, c2.length) - 1); q >= 0; q--) {
        if (c1[q].length > 0)
          c2[q] = c1[q];
      }
      list.remove(minI);
      if ((--l) <= 1)
        return;

      for (q = minI + 1; q <= l; q++) {
        kk = matrix[q];
        matrix[q - 1] = kk;
        System.arraycopy(kk, minI + 1, kk, minI, q - minI - 1);
      }

      for (q = (l - 1); q > minJ; q--) {
        matrix[q][minJ] = compareLines(c2, list.get(q));
      }
      kk = matrix[minJ];
      for (--minJ; minJ >= 0; minJ--) {
        kk[minJ] = compareLines(c2, list.get(minJ));
      }
    }
  }

  /**
   * Compare two lines
   * 
   * @param l1
   *          the first line
   * @param l2
   *          the second line
   * @return the comparison result
   */
  private static final int compareLines(final double[][][] l1,
      final double[][][] l2) {
    int i, l, min1, max1, min2, max2;
    boolean b1, b2;

    l = Math.min(l1.length, l2.length);

    if (l <= 0)
      return -1;

    min1 = min2 = l;
    max1 = max2 = -1;
    for (i = (l - 1); i >= 0; i--) {

      b1 = (l1[i].length > 0);
      b2 = (l2[i].length > 0);

      if (b1 && b2)
        return -1;

      if (b1) {

        if (min1 > i)
          min1 = i;

        if (max1 < i)
          max1 = i;

        if ((max2 >= min1) && (max1 >= min2))
          return -1;

      } else if (b2) {

        if (min2 > i)
          min2 = i;

        if (max2 < i)
          max2 = i;

        if ((max2 >= min1) && (max1 >= min2))
          return -1;
      }
    }

    // if (min1 == (max2 + 1))
    // return compareSingleLine(l1[min1][0], l2[max2][0]);
    // else if (max1 == (min2 - 1))
    // return compareSingleLine(l1[max1][0], l2[min2][0]);
    // else if (max1 > max2)
    // return compareSingleLine(l1[min1][0], l2[max2][0]) * (min1 - max2);
    // else
    // return compareSingleLine(l2[min2][0], l1[max1][0]) * (min2 - max1);

    if (max1 > max2) {
      i = compareSingleLine(l1[min1][0], l2[max2][0]);
      l = (min1 - max2);
    } else {
      i = compareSingleLine(l2[min2][0], l1[max1][0]);
      l = (min2 - max1);
    }

    if ((i < 0) || (l > 4))
      return -1;
    if (l > 1)
      return (i * l) + 2;
    return i;
  }

  /**
   * Compare a single line.
   * 
   * @param d1
   *          the first line
   * @param d2
   *          the second line
   * @return the result;
   */
  private static final int compareSingleLine(final double[] d1,
      final double[] d2) {
    int c, i;
    double a1, a2;

    c = 0;
    for (i = (Math.min(d1.length, d2.length) - 1); i >= 0; i--) {
      a1 = d1[i];
      a2 = d2[i];
      if (Double.compare(a1, a2) != 0) {
        if ((++c) > 2)
          return -1;
        if ((!(Mathematics.isNumber(a1))) || (!(Mathematics.isNumber(a2))))
          return -1;
        a1 = Math.abs(a1);
        a2 = Math.abs(a2);
        if (a1 <= 0.0d)
          a1 = MIN_CMP;
        else
          a1 = Math.log10(a1);
        if (a2 <= 0.0d)
          a2 = MIN_CMP;
        else
          a2 = Math.log10(a2);
        if (Math.abs(a1 - a2) > 1.0d)
          return -1;
      }
    }
    return c;
  }

  /**
   * This internal function unites consecutive units that all contaning the
   * same elements into consecutive units that all contain similar
   * elements.
   * 
   * @param data
   *          the data array
   * @return a unified data array
   */
  public static final double[][][][] unite(final double[][][][] data) {
    SimpleList<double[][][]> list;
    int i;
    double[][][][] v;

    list = new SimpleList<double[][][]>(0);
    list.m_data = data;
    list.m_count = data.length;
    unite(list);
    i = list.m_count;
    if (i >= data.length)
      return data;
    v = new double[i][][][];
    list.copyToArray(v, i);
    return v;
  }

  /**
   * <p>
   * This internal function splits a data array into consecutive units all
   * contaning the same elements.
   * </p>
   * <p>
   * Access the result array as follows <code>res[A][B][C][D]</code>
   * where
   * <ul>
   * <li><code>[A]</code> identifies the data line</li>
   * <li><code>[B]</code> identifies the unit</li>
   * <li><code>[C]</code> identifies the (valid) row in that file</li>
   * <li><code>[D]</code> identifies the column in that row</li>
   * </ul>
   * </p>
   * 
   * @param data
   *          the data array
   * @return an array with with the single lines
   */
  public static final double[][][][] split(final double[][][] data) {
    SimpleList<double[][][]> sl;
    double[][][][] d;
    int l;

    sl = new SimpleList<double[][][]>(-1);
    split(sl, data);
    l = sl.m_count;
    if (l <= 0)
      return EMPTY_DOUBLE4;
    d = new double[l][][][];
    sl.copyToArray(d, l);
    return d;
  }

  /**
   * <p>
   * This internal function splits a data array into consecutive units all
   * contaning the same elements.
   * </p>
   * <p>
   * Access the result array as follows <code>res[A][B][C][D]</code>
   * where
   * <ul>
   * <li><code>[A]</code> identifies the data line</li>
   * <li><code>[B]</code> identifies the unit</li>
   * <li><code>[C]</code> identifies the (valid) row in that file</li>
   * <li><code>[D]</code> identifies the column in that row</li>
   * </ul>
   * </p>
   * 
   * @param data
   *          the data array
   * @return an array with with the single lines
   */
  public static final double[][][][] splitAndUnite(final double[][][] data) {
    SimpleList<double[][][]> sl;
    double[][][][] d;
    int l;

    sl = new SimpleList<double[][][]>(-1);
    split(sl, data);
    l = sl.m_count;
    if (l <= 0)
      return EMPTY_DOUBLE4;
    unite(sl);
    l = sl.m_count;
    if (l <= 0)
      return EMPTY_DOUBLE4;

    d = new double[l][][][];
    sl.copyToArray(d, l);
    return d;
  }

  /**
   * Remove cross-unit duplicates
   * 
   * @param data
   *          the array to remove duplicates within
   */
  public static final void removeDuplicates(final double[][][] data) {
    int i, j, i2, j2, lastj, lasti;
    double[][] d1, d2;
    double[] c1;
    boolean b;

    for (i = (data.length - 1); i > 0; i--) {
      d1 = data[i];
      for (j = (d1.length - 1); j >= 0; j--) {
        c1 = d1[j];
        if (c1.length > 0) {
          outer: {
            lasti = lastj = -1;
            inner: for (i2 = (i - 1); i2 >= 0; i2--) {
              d2 = data[i2];
              {
                for (j2 = (d2.length - 1); j2 >= 0; j2--) {
                  if (Utils.testDoubleArrayEqual(d2[j2], c1)) {
                    if (lasti >= 0) {
                      if (data[lasti] == d1)
                        data[lasti] = d1.clone();
                      data[lasti][lastj] = EMPTY_DOUBLE1;
                    }
                    lasti = i2;
                    lastj = j2;
                    continue inner;
                  }
                }
                break outer;
              }
            }
          }
        }
      }

      j = d1.length;
      if (j <= 0)
        data[i] = EMPTY_DOUBLE2;
      else {
        b = true;
        for (j = (d1.length - 1); j >= 0; j--) {
          if (d1[j].length <= 0)
            d1[j] = EMPTY_DOUBLE1;
          else
            b = false;
        }
        if (b)
          data[i] = EMPTY_DOUBLE2;
      }
    }
  }

  /**
   * Convert a csv string to a <code>double</code> array.
   * 
   * @param ss
   *          the string
   * @return the <code>double</code> array or <code>null</code> if none
   *         could be created
   */
  public static final double[] stringsToDoubleArray(final String[] ss) {
    double[] d;
    int i;
    String s;
    boolean valid;

    i = ss.length;

    d = new double[i];
    valid = true;
    for (--i; i >= 0; i--) {
      s = ss[i].toLowerCase();

      if (s.contains("-inf"))d[i] = Double.NEGATIVE_INFINITY;//$NON-NLS-1$
      else if (s.contains("inf"))d[i] = Double.POSITIVE_INFINITY;//$NON-NLS-1$
      else if (s.contains("-infinity"))d[i] = Double.NEGATIVE_INFINITY;//$NON-NLS-1$
      else if (s.contains("infinity"))d[i] = Double.POSITIVE_INFINITY;//$NON-NLS-1$
      else if (s.contains("NaN"))d[i] = Double.NaN;//$NON-NLS-1$
      else {
        try {
          d[i] = Double.parseDouble(s.trim());
        } catch (Throwable tt) {
          valid = false;
        }
      }
    }

    if (valid)
      return d;
    return EMPTY_DOUBLE1;
  }

  /**
   * <p>
   * Read the objective output stored in a file.
   * </p>
   * <p>
   * For each single line that contains data in the file, an array of
   * <code>double</code> is created, filled with that data.
   * </p>
   * 
   * @param file
   *          the file to read
   * @param removeDuplicates
   *          <code>true</code> if and only if duplicates are to be
   *          removed per file
   * @param ignoreFirstLine
   *          <code>true</code> if and only if the first line in the file
   *          should be ignored (because it contains the headline)
   * @return the data
   */
  public static final double[][] readFile(final Object file,
      final boolean removeDuplicates, final boolean ignoreFirstLine) {
    return readFile(file, removeDuplicates, ignoreFirstLine,
        new SimpleList<Object>(), new ReaderLoader());
  }

  /**
   * <p>
   * Serialize the data to a file.
   * </p>
   * <p>
   * Format the data array as follows <code>data[A][B][C]</code> where
   * <ul>
   * <li><code>[A]</code> identifies the generation or a unit</li>
   * <li><code>[B]</code> identifies the (valid) row in the unit</li>
   * <li><code>[C]</code> identifies the column in that row</li>
   * </ul>
   * </p>
   * 
   * @param data
   *          the <code>double</code> data, maybe read from objective
   *          printer files.
   * @param columns
   *          The column identifiers. This ids decide which columns of
   *          <code>data</code> should be printed. <code>-1</code>
   *          stands for the "generation"-index
   * @param file
   *          the target file
   */
  public static final void doublesToCSV(final double[][][][] data,
      final int[] columns, final Object file) {
    TextWriter w;
    int i;
    double[][][] d;
    boolean b;

    try {
      if (file instanceof TextWriter)
        w = ((TextWriter) file);
      else
        w = new TextWriter(IO.getWriter(file));

      if (w != null) {
        try {
          b = false;
          for (i = (data.length - 1); i >= 0; i--) {

            d = data[i];
            if ((d != null) && (d.length > 0)) {

              if (b) {
                w.ensureNewLine();
                w.newLine();
                w.newLine();
              } else
                b = true;

              w.addRef();
              doublesToCSV(d, columns, w);

            }

          }
        } finally {
          w.release();
        }
      }

    } catch (Throwable tt) {
      //
    }

  }

  /**
   * <p>
   * Serialize the data to a file.
   * </p>
   * <p>
   * Format the data array as follows <code>data[A][B][C]</code> where
   * <ul>
   * <li><code>[A]</code> identifies the generation or a unit</li>
   * <li><code>[B]</code> identifies the (valid) row in the unit</li>
   * <li><code>[C]</code> identifies the column in that row</li>
   * </ul>
   * </p>
   * 
   * @param data
   *          the <code>double</code> data, maybe read from objective
   *          printer files.
   * @param columns
   *          The column identifiers. This ids decide which columns of
   *          <code>data</code> should be printed. <code>-1</code>
   *          stands for the "generation"-index
   * @param file
   *          the target file
   */
  public static final void doublesToCSV(final double[][][] data,
      final int[] columns, final Object file) {

    TextWriter w;
    double[][] ge;
    double[] sg;
    int i, j, k, l;

    try {
      if (file instanceof TextWriter)
        w = ((TextWriter) file);
      else
        w = new TextWriter(IO.getWriter(file));

      try {
        for (i = 0; i < data.length; i++) {
          ge = data[i];
          if (ge == null)
            continue;
          for (j = 0; j < ge.length; j++) {
            sg = ge[j];
            if ((sg == null) || (sg.length <= 0))
              continue;
            w.ensureNewLine();
            for (k = 0; k < columns.length; k++) {
              if (k > 0)
                w.writeCSVSeparator();
              l = columns[k];
              if ((l < 0) || (l >= sg.length))
                w.writeInt(i);
              else
                w.writeDouble(sg[l]);
            }
          }
        }
      } finally {
        w.release();
      }

    } catch (Throwable t) {
      ErrorUtils.onError(t);
    }
  }
}
